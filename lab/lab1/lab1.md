# 笔记
一. 进程和内存
1. 进程通过系统调用进入内核，一个进程在用户空间和内核空间之间交替执行。
2. fork创建新进程，在父进程中，fork返回子进程的PID；在子进程中，fork返回零
3. exit使调用进程停止执行并释放资源。exit(0)表示成功，exit(1)表示失败。
4. wait阻塞等待子进程的退出并返回退出子进程的PID，同时将退出状态传递给调用wait的地址；如果调用者没有子进程，wait立即返回-1。如果父进程不关心子进程的退出状态，它可以传递一个0地址给wait(如：pid = wait((int *) 0);)。
5. 尽管最初子进程与父进程有着相同的内存内容，但是二者在运行中拥有不同的内存空间和寄存器。
6. exec进行进程替换。本身并不创建新进程，所以前后进程的ID并没有改变。exex执行成功就退出进程，否则执行后面的代码。

二. I/O和文件描述符
1. 文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。见下图
![Alt text](image1.png)
2. read(fd，buf，n)从文件描述符fd读取最多n字节，将它们复制到buf，并返回读取的字节数。read从当前文件偏移量开始读取数据。
3. write(fd，buf，n)将buf中的n字节写入文件描述符fd，并返回写入的字节数。只有发生错误时才会写入小于n字节的数据。与读一样，write在当前文件偏移量处写入数据，然后将该偏移量向前推进写入的字节数：每个write从上一个偏移量停止的地方开始写入。
4. read和write即是cat的实现原理：文件描述符0和1的使用
```C++
// cat.c
char buf[512];
int n;
for (;;) {
    n = read(0, buf, sizeof buf);
    if (n == 0)
        break;
    if (n < 0) {
        fprintf(2, "read error\n");
        exit(1);
    }
    if (write(1, buf, n) != n) {
        fprintf(2, "write error\n");
        exit(1);
    }
}
```
5. close系统调用释放一个文件描述符
6. cat重定向实现原理
```C++
char* argv[2];
argv[0] = "cat";
argv[1] = 0;
if (fork() == 0) {
    // 在子进程中，关闭标准输入0(即无法再从键盘获取数据)
    close(0);
    // open函数会将input.txt和标准输入绑定（最小的未使用的fd）
    open("input.txt", O_RDONLY);
    // 在环境变量中寻找cat文件，然后将argv作为参数传递进去
    exec("cat", argv);
}
```
总结：fork子进程，关闭fd0，open一个新的占据最小未使用的fd0，在使用exec重新调用即可完成重定向(其他的重定向也一样)。
7. fork复制了文件描述符表，但是每个基础文件偏移量在父文件和子文件之间是共享的。比如：
```C++
// 父子进程分别往同一个fd里面写入数据，但共享文件偏移量，因此不会进行覆盖，输出的仍然是"hello world"
if (fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
```
8. dup复制一个现有的文件描述符(引用)。两个文件描述符共享一个偏移量。
```C++
// fd和1是同一个文件描述符，因此最终结果也是"hello world"
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

三. 管道
1. 管道是一个小的内核缓冲区。并通过以下代码实现了grep fork sh.c | wc -l